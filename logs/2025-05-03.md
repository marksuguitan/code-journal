# Coding Journal

**Date:**: 2025-05-03

---

# Lessons

## 1. Architect Lambda Functions and SDKs Properly

- Build a proxy Lambda function that routes requests to LLM providers like OpenAI, Anthropic, and Google.
- Create an `AI` class SDK to standardize communication between your apps and the backend.
- Keep API keys and logic in the backend to improve security and maintainability.

---

## 2. Eliminate Redundant Lambda Wrappers

- Avoid wrapping the `AI` class in an extra Lambda unless necessary.
- Use the class directly in frontend or backend apps for faster performance and simpler architecture.

---

## 3. Route LLM Requests Through the Backend

- Never call LLM APIs directly from the frontend.
- Create a backend service to manage API keys, rate limits, retries, and logging.
- Use the backend to abstract provider selection and ensure a secure, consistent interface.

---

## 4. Manage Dependencies with Best Practices

- Track dependencies using `requirements.txt` or `pyproject.toml`.
- Pin package versions to avoid conflicts.
- Enable automated updates with tools like `dependabot`.
- Always review changelogs before upgrading libraries.

---

## 5. Use Virtual Environments for Local Dev

- Run `python -m venv .venv && source .venv/bin/activate` to create a clean dev environment.
- Keep development isolated from the system Python environment.

---

## 6. Organize Dependencies for SAM Projects

- Decide between a root-level `requirements.txt` or one per function folder.
  - Use a single file for shared dependencies.
  - Use per-function files to reduce deployment package size.
- Let `sam build` handle dependency installation for each function.

---

## 7. Remember Each Lambda is Isolated

- Treat each function as its own environment with its own files and environment variables.
- Donât rely on shared memory or imports between functions at runtime.

---

## 8. Document Each Function with a README

- Place a `README.md` in each function folder.
- Include:
  - Purpose
  - Trigger (API, S3, etc.)
  - Input/output examples
  - Required environment variables
  - Dependencies
  - Local testing instructions

---

## 9. Control Packaging and Costs

- Donât expect SAM to analyze your Python imports â explicitly include necessary files.
- Use `.gitignore` and `.dockerignore` to exclude dev and build artifacts.
- Keep deployment packages small and clean.

---

## 10. Follow General Best Practices

- Write clean, modular, testable code.
- Use automation for changelogs and updates.
- Secure sensitive config with environment variables or Secrets Manager.
- Keep your architecture lean and scalable.


---

## 11. Pretty-Print JSON Output with `json.dumps()`

- Use `json.dumps(obj, indent=2)` to format JSON with readable indentation.
- Pass the `indent` argument to add line breaks and spacing for clarity.
- Prefer pretty-printed JSON when debugging or logging structured data.


# What's New

- `hypersynaptic` python package was created using AWS CodeArtifact. Didn't want to use PyPi because it is public.
  - see: https://us-east-1.console.aws.amazon.com/codesuite/codeartifact/d/546423515903/hypersynaptic/r/python-sdk/p/pypi/hypersynaptic/versions?region=us-east-1&package-versions-meta=eyJmIjp7fSwicyI6e30sIm4iOjIwLCJpIjowfQ
