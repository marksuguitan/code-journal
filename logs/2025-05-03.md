# Coding Journal

**Date:**: 2025-05-03

---

# Lessons

## 1. AWS Lambda Function Architecture & SDK Usage

- You built a proxy Lambda endpoint that interfaces with multiple LLM providers (OpenAI, Anthropic, Google).
- You also built an `AI` class SDK to simplify how your apps communicate with this backend.
- This avoids exposing API keys and keeps LLM logic centralized and secure.

---

## 2. Why Avoid a Redundant Lambda Wrapper

- Using a Lambda function just to wrap the `AI` class isn’t needed — instead, use the class directly in your apps.
- This reduces complexity, avoids unnecessary latency, and improves maintainability.

---

## 3. Frontend vs Backend for LLM Calls

- **Frontend should not call LLM APIs directly** — doing so exposes API keys and lacks control.
- Route LLM requests through a backend that handles auth, metering, and rate limits.
- Backend functions can handle provider selection logic, retries, and auditing.

---

## 4. Dependency Management Best Practices

- Use `requirements.txt` (or `pyproject.toml` with `poetry`) to track all dependencies.
- Pin versions to avoid "it works on my machine" problems.
- Use tools like `dependabot` to automate dependency updates with changelogs.
- Always review changelogs before upgrading libraries.

---

## 5. Virtual Environments (venv) in SAM Projects

- Not required for AWS Lambda runtime, but highly recommended during local dev.
- Helps isolate dependencies and avoid polluting global Python environment.
- Easy to use with: `python -m venv .venv && source .venv/bin/activate`.

---

## 6. Managing Dependencies in SAM Projects

- You can have one root-level `requirements.txt` or separate ones per function folder.
  - **Single file:** simpler, shared deps.
  - **Per function:** leaner packages, better isolation.
- SAM will install dependencies into the `.aws-sam/build` dir for each function automatically.

---

## 7. Lambda Environments Are Isolated

- Each deployed Lambda function runs in its own isolated container with its own filesystem and environment variables.
- They do *not* share Python environments or memory across invocations.

---

## 8. README.md per Function is Encouraged

Each function should have its own `README.md` with:
- Purpose
- Event trigger
- Example inputs/outputs
- Env vars
- Dependencies
- Local testing instructions

---

## 9. Cost and Packaging Tips

- SAM doesn’t parse import statements; it packages what’s in your function folders.
- Always ensure your function folder includes all required files and `requirements.txt`.
- Use `.dockerignore` and `.gitignore` to avoid bundling unnecessary files.

---

## 10. General Best Practices

- Keep functions small, focused, and well-documented.
- Favor automation (e.g., changelogs, updates).
- Secure secrets with environment variables or AWS Secrets Manager.
- Prefer modularity and clean architecture to avoid spaghetti code.

---

## 11. json.dumps() Pretty-Print

- json.dumps() has a feature that can make json output "pretty" or a "Pretty-print the dictionary" feature which looks like this:

  ```python
  json.dumps(response, indent=2)
  ```

  The pretty-print feature in Python's JSON library is activated by passing the indent argument to json.dumps(). When you specify a number (e.g. indent=2), the output JSON string will include newlines and spaces that correspond to the provided indentation level. This makes the structure of the JSON data much clearer and easier to read for humans.


# What's New

- `hypersynaptic` python package was created using AWS CodeArtifact. Didn't want to use PyPi because it is public.
  - see: https://us-east-1.console.aws.amazon.com/codesuite/codeartifact/d/546423515903/hypersynaptic/r/python-sdk/p/pypi/hypersynaptic/versions?region=us-east-1&package-versions-meta=eyJmIjp7fSwicyI6e30sIm4iOjIwLCJpIjowfQ
